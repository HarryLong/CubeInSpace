#version 430

layout (local_size_x = 32, local_size_y = 32) in;

uniform uint n_clusters;

// CLUSTER DATA
uniform sampler2D slope_cluster_data_texture;
uniform sampler2DArray temperature_cluster_data_texture;
uniform sampler2DArray daily_illumination_cluster_data_texture;
uniform sampler2DArray weighted_avg_soil_humidity_cluster_data_texture;

// RESOURCE DATA
uniform sampler2D slope_texture;
uniform sampler2DArray temperature_texture;
uniform sampler2DArray daily_illumination_texture;
uniform sampler2DArray weighted_avg_soil_humidity_texture;

layout(binding = 0, r32ui) uniform uimage2D resulting_cluster_memberships;

struct ClusteringEntities
{
    float slope;
    float temp[2];
    uint illumination[2];
    float soil_humidities[12];
};

float calculateDistance(in ClusteringEntities cluster_one, in ClusteringEntities cluster_two)
{
    float dist = 0;

    // SLOPE
    dist += abs(cluster_one.slope-cluster_two.slope);

    for(int i = 0; i < 2; i++)
    {
        dist += abs(cluster_one.temp[i]-cluster_two.temp[i]); // TEMPERATURE
        dist += abs(cluster_one.illumination[i]-cluster_two.illumination[i]); // ILLUMINATION
    }

    return dist;
}

void main()
{
    uvec2 size = textureSize(slope_texture, 0);

    ivec2 global_idx;
    global_idx.x = int(gl_WorkGroupID.x * gl_WorkGroupSize.x + gl_LocalInvocationID.x);
    global_idx.y = int(gl_WorkGroupID.y * gl_WorkGroupSize.y + gl_LocalInvocationID.y);
    bool valid = global_idx.x < int(size.x) && global_idx.y < int(size.y);

    if(valid)
    {
        vec2 resource_texture_coord = vec2(float(global_idx.x)/(size.x-1), float(global_idx.y)/(size.y-1));
        ClusteringEntities resource_entities;
        ClusteringEntities cluster_entities;

        /**********************
         * LOAD RESOURCE DATA *
         **********************/
        // Slope
        resource_entities.slope = texture(slope_texture, resource_texture_coord).r;
        // Temperature
        resource_entities.temp[0] = texture(temperature_texture, vec3(resource_texture_coord,0)).r * 127; // JUN
        resource_entities.temp[1] = texture(temperature_texture, vec3(resource_texture_coord,1)).r * 127; // DEC
        // Min illumination
        resource_entities.illumination[0] = uint(texture(daily_illumination_texture, vec3(resource_texture_coord,0)).r * 255); // MIN
        resource_entities.illumination[1] = uint(texture(daily_illumination_texture, vec3(resource_texture_coord,1)).r * 255); // MAX
        // Soil humidity
        for(int month = 0; month < 12; month++)
        {
            resource_entities.soil_humidities[month] = texture(weighted_avg_soil_humidity_texture, vec3(resource_texture_coord, month)).r;
        }

        /************************
         * FIND CLOSEST CLUSTER *
         ************************/
        float closest_distance = 0;
        uint closest_cluster_idx = 0;
        for(uint cluster_idx = 0; cluster_idx < n_clusters; cluster_idx++)
        {
            vec2 cluster_texture_coord = vec2(float(cluster_idx)/(n_clusters-1),0);

            /*********************
             * LOAD CLUSTER DATA *
             *********************/
            // Slope
            cluster_entities.slope = texture(slope_cluster_data_texture, cluster_texture_coord).r;
            // Temperature
            cluster_entities.temp[0] = texture(temperature_cluster_data_texture, vec3(cluster_texture_coord,0)).r * 127;
            cluster_entities.temp[1] = texture(temperature_cluster_data_texture, vec3(cluster_texture_coord,1)).r * 127;
            // Min illumination
            cluster_entities.illumination[0] = uint(texture(daily_illumination_cluster_data_texture, vec3(cluster_texture_coord,0)).r * 255);
            cluster_entities.illumination[1] = uint(texture(daily_illumination_cluster_data_texture, vec3(cluster_texture_coord,1)).r * 255);
            // Soil humidity
            for(int month = 0; month < 12; month++)
            {
                resource_entities.soil_humidities[month] = texture(weighted_avg_soil_humidity_texture, vec3(cluster_texture_coord, month)).r;
            }

            float cluster_distance = calculateDistance(resource_entities, cluster_entities);

            if(cluster_idx == 0 || cluster_distance < closest_distance)
            {
                closest_distance = cluster_distance;
                closest_cluster_idx = cluster_idx;
            }
        }
        imageStore(resulting_cluster_memberships, global_idx, uvec4(closest_cluster_idx,0,0,0));
    }
    memoryBarrierImage();
}

