#version 430

layout (local_size_x = 32, local_size_y = 32) in;

layout(binding = 0, r32ui) uniform coherent uimage2D water_heightmap;
layout(binding = 1, r32f) uniform coherent image2D terrain_heightmap;

int meters_to_mm(in float meters)
{
    return int(meters*1000);
}

ivec2 to_local(in ivec2 global_coordinate_to_translate, in ivec2 global_reference_cell)
{
    return ivec2(global_coordinate_to_translate.x-global_reference_cell.x+1,
                 global_coordinate_to_translate.y-global_reference_cell.y+1);
}

ivec2 to_global(in ivec2 local_coordinate_to_translate, in ivec2 global_reference_cell)
{
    return ivec2(global_reference_cell.x+(local_coordinate_to_translate.x-1),
                 global_reference_cell.y+(local_coordinate_to_translate.y-1));
}

const int _BORDER_INSERT_ALL_WATER = -1;

void main()
{
    uvec2 heightmap_size = imageSize(water_heightmap);
    // WATER HEIGHTMAP IMAGE INDICES
    ivec2 global_idx;
    global_idx.x = int(gl_WorkGroupID.x * gl_WorkGroupSize.x + gl_LocalInvocationID.x); // + 1 for padding
    global_idx.y = int(gl_WorkGroupID.y * gl_WorkGroupSize.y + gl_LocalInvocationID.y); // + 1 for padding

    bool valid = global_idx.x < int(heightmap_size.x) && global_idx.y < int(heightmap_size.y) && imageLoad(water_heightmap, global_idx).x > 0;

    uint water_to_add[3][3];
    int terrain_heights[3][3];
    uint water_heights[3][3];
    uint aggregate_heights[3][3];
    for(int i = 0; i < 3; i++)
    {
        for(int ii = 0; ii < 3; ii++)
        {
            terrain_heights[i][ii] = 0;
            water_heights[i][ii] = 0;
            aggregate_heights[i][ii] = 0;
            water_to_add[i][ii] = 0;
        }
    }
    uint water_to_remove = 0;
    vec2 global_min;
    vec2 global_max;

    bool dismiss_all_water = false;

    /*************
     * LOAD DATA *
     *************/
    if(valid)
    {
        for(int global_x = global_idx.x-1; global_x <= global_idx.x+1 && !dismiss_all_water; global_x++)
        {
            for(int global_y = global_idx.y-1; global_y <= global_idx.y+1 && !dismiss_all_water ; global_y++)
            {
                uvec2 local_coordinate = to_local(ivec2(global_x, global_y), global_idx);

                /******************
                 * TERRAIN HEIGHT *
                 ******************/
                int terrain_height = meters_to_mm(imageLoad(terrain_heightmap, ivec2(global_x+1, global_y+1)).x); //meters_to_mm(texture(height_map_texture, tmp_terrain_heightmap_idx) * scale);
                terrain_heights[local_coordinate.x][local_coordinate.y] = terrain_height;

                /****************
                 * WATER HEIGHT *
                 ****************/
                if(global_x < 0 || global_x >= heightmap_size.x || global_y < 0 || global_y >= heightmap_size.y)
                {
                    if(terrain_height < 0)
                    {
                        water_to_remove = imageLoad(water_heightmap, global_idx).x;
                        dismiss_all_water = true;
                    }
                    else // _BORDER_INSERT_NO_WATER
                    {
                        //TODO: Make this cell unavailable for water
                        terrain_heights[local_coordinate.x][local_coordinate.y] = int(1e20); // Make it huge: ugly but save some hassle
                        aggregate_heights[local_coordinate.x][local_coordinate.y] = int(1e20);
                    }
                }
                else
                {
                    uint water_height = imageLoad(water_heightmap, ivec2(int(global_x), int(global_y))).x;
                    water_heights[local_coordinate.x][local_coordinate.y] = water_height;
                    aggregate_heights[local_coordinate.x][local_coordinate.y] = water_height + terrain_height;
                }
            }
        }
    }

    /****************************
     * CALCULATE WATER MOVEMENT *
     ****************************/
    if(valid && !dismiss_all_water)
    {
        // Now check whether or not the surrounding cells can take all water from current cell
        uint aggregate_height_diff = 0;
        uint height_diffs[3][3]; // Diff between this cells *TERRAIN* height and surrounding cells *AGGREGATE* height
        uvec2 lowest_surrounding_cell = uvec2(1,1);
        uint maximum_height_diff = 0;
        for(uint local_x = 0; local_x < 3; local_x++)
        {
            for(uint local_y = 0; local_y < 3; local_y++)
            {
                uint height_diff = 0;
                if(terrain_heights[1][1] > aggregate_heights[local_x][local_y])
                {
                    height_diff = terrain_heights[1][1] - aggregate_heights[local_x][local_y];
                }
                height_diffs[local_x][local_y] = height_diff;
                aggregate_height_diff += height_diff;
                if(height_diff > maximum_height_diff)
                {
                    maximum_height_diff = height_diff;
                    lowest_surrounding_cell = uvec2(local_x, local_y);
                }
            }
        }


        /*
        Two possible scenarios:
            1. There is space to evacuate all water into surrounding cells - Split water content in surrounding cells depending on the height difference
            2. There is not enough space to evacuate water into surrounding cells - Add most possible water in surrounding cells
        */
        uint aggregate_water_removed = 0;
        if(aggregate_height_diff >= water_heights[1][1]) // Scenario 1
        {
            for(uint local_x = 0; local_x < 3; local_x++)
            {
                for(uint local_y = 0; local_y < 3; local_y++)
                {
                    float movement_percentage = float(height_diffs[local_x][local_y])/float(aggregate_height_diff);
                    uint water_movement = uint(round(movement_percentage * water_heights[1][1]));
                    water_to_add[local_x][local_y] = water_movement;
                    aggregate_water_removed += water_movement;
                }
            }

             // BALANCE MISSING/TOO MUCH WATER
            if(aggregate_water_removed < water_heights[1][1]) // Insert all to lowest surrounding cell
            {
                water_to_add[lowest_surrounding_cell.x][lowest_surrounding_cell.y] += (water_heights[1][1]-aggregate_water_removed);
            }
            while(aggregate_water_removed > water_heights[1][1]) // Remove water from cells in which water was inserted
            {
                for(uint local_x = 0; local_x < 3 && aggregate_water_removed > water_heights[1][1]; local_x++)
                {
                    for(uint local_y = 0; local_y < 3 && aggregate_water_removed > water_heights[1][1]; local_y++)
                    {
                        if(water_to_add[local_x][local_y] > 0)
                        {
                            water_to_add[local_x][local_y]--;
                            aggregate_water_removed--;
                        }
                    }
                }
            }
            water_to_remove = water_heights[1][1]; // Remove all water from cell
        }
        else // Scenario 2
        {
            bool cells_in_which_to_insert_water[3][3];
            // First set all cells with lower height to take water
            for(uint local_x = 0; local_x < 3; local_x++)
            {
                for(uint local_y = 0; local_y < 3; local_y++)
                {
                    cells_in_which_to_insert_water[local_x][local_y] = aggregate_heights[local_x][local_y] < aggregate_heights[1][1];
                }
            }

            bool balance_found = false;
            while(!balance_found)
            {
                uint total_height = aggregate_heights[1][1];
                uint cell_count = 1;
                water_to_remove = 0;
                // First calculate the target balance_height based on cells which are currently deemed available to take water
                for(uint local_x = 0; local_x < 3; local_x++)
                {
                    for(uint local_y = 0; local_y < 3; local_y++)
                    {
                        water_to_add[local_x][local_y] = 0;
                        if(cells_in_which_to_insert_water[local_x][local_y])
                        {
                            total_height += aggregate_heights[local_x][local_y];
                            cell_count++;
                        }
                    }
                }

                // Calculate the balance height
                uint dividable_total_height = total_height;
                while(dividable_total_height > 0 && dividable_total_height % cell_count != 0)
                {
                    dividable_total_height--;
                }
                uint target_balance_height = dividable_total_height/cell_count;
                balance_found = true; // Start positive
                for(uint local_x = 0; local_x < 3; local_x++)
                {
                    for(uint local_y = 0; local_y < 3; local_y++)
                    {
                        if(cells_in_which_to_insert_water[local_x][local_y])
                        {
                            if(target_balance_height > aggregate_heights[local_x][local_y])
                            {
                                uint water_movement = target_balance_height-aggregate_heights[local_x][local_y];
                                water_to_remove += water_movement;
                                water_to_add[local_x][local_y] = water_movement;
                            }
                            else
                            {
                                cells_in_which_to_insert_water[local_x][local_y] = false;
                                balance_found = false;
                            }
                        }
                    }
                }
            }
        }
    }
    // Sync threads before writing
    barrier();
    memoryBarrierImage();
    memoryBarrier();
    /***********************
     * WRITE ADDITION DATA *
     ***********************/
    if(valid && !dismiss_all_water)
    {
        // Add the water to surrounding cells
        for(uint local_x = 0; local_x < 3; local_x++)
        {
            for(uint local_y = 0; local_y < 3; local_y++)
            {
                ivec2 global_cell = to_global(ivec2(local_x, local_y), global_idx);
                imageAtomicAdd(water_heightmap, global_cell, water_to_add[local_x][local_y]);
            }
        }
    }
    barrier();
    memoryBarrierImage();
    memoryBarrier();
    /**********************
     * WRITE REMOVAL DATA *
     **********************/
    if(valid)
    {
        // Remove the water from current cell
//        uint new_height = water_heights[1][1];
//        if(water_to_remove > 0)
//        {
//            new_height -= water_to_remove;
//        }
//        imageStore(water_heightmap, i_global_idx, uvec4(new_height,0,0,0));
//        if(dismiss_all_water)
//            imageAtomicAdd(water_heightmap, global_idx, 100);
//        else
            imageAtomicAdd(water_heightmap, global_idx, -1 * water_to_remove);
    }
    // Sync threads to ensure all writes have been performed
    barrier();
    memoryBarrierShared();
    memoryBarrier();
}
